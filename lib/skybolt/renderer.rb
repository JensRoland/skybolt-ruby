# frozen_string_literal: true

require "json"
require "cgi"
require "uri"

module Skybolt
  # Skybolt asset renderer.
  #
  # Reads the render-map.json generated by @skybolt/vite-plugin and outputs
  # optimized HTML tags with intelligent caching via Service Workers.
  class Renderer
    # @param render_map_path [String] Path to render-map.json generated by Vite plugin
    # @param cookies [Hash, nil] Cookie hash (defaults to empty hash)
    # @param cdn_url [String, nil] Optional CDN URL prefix
    def initialize(render_map_path, cookies: nil, cdn_url: nil)
      json = File.read(render_map_path)
      @map = JSON.parse(json)
      @client_cache = parse_cookie((cookies || {})["sb_assets"] || "")
      @cdn_url = cdn_url&.chomp("/")
    end

    # Render CSS asset.
    #
    # On first visit: inlines CSS with sb-* attributes for caching
    # On repeat visit: outputs <link> tag (Service Worker serves from cache)
    #
    # @param entry [String] Source file path (e.g., 'src/css/main.css')
    # @param async [Boolean] Load CSS asynchronously (non-render-blocking)
    # @return [String] HTML string
    def css(entry, async: false)
      asset = @map.dig("assets", entry)
      return comment("Skybolt: asset not found: #{entry}") if asset.nil?

      url = resolve_url(asset["url"])

      # Client has current version - external link (SW serves from cache)
      if cached?(entry, asset["hash"])
        if async
          # Preload + onload swap for non-blocking load
          return %(<link rel="preload" href="#{esc(url)}" as="style" onload="this.rel='stylesheet'">) +
                 %(<noscript><link rel="stylesheet" href="#{esc(url)}"></noscript>)
        end
        return %(<link rel="stylesheet" href="#{esc(url)}">)
      end

      # First visit - inline with cache attributes
      if async
        # media="print" trick: browser parses but doesn't apply until onload swaps to "all"
        return %(<style media="print" onload="this.media='all'" sb-asset="#{esc(entry)}:#{esc(asset["hash"])}" sb-url="#{esc(url)}">#{asset["content"]}</style>)
      end

      %(<style sb-asset="#{esc(entry)}:#{esc(asset["hash"])}" sb-url="#{esc(url)}">#{asset["content"]}</style>)
    end

    # Render JavaScript asset.
    #
    # On first visit: inlines JS with sb-* attributes for caching
    # On repeat visit: outputs <script> tag (Service Worker serves from cache)
    #
    # @param entry [String] Source file path (e.g., 'src/js/app.js')
    # @param is_module [Boolean] Whether to load as ES module (default: true)
    # @return [String] HTML string
    def script(entry, is_module: true)
      asset = @map.dig("assets", entry)
      return comment("Skybolt: asset not found: #{entry}") if asset.nil?

      url = resolve_url(asset["url"])
      type_attr = is_module ? ' type="module"' : ""

      # Client has current version - external script (SW serves from cache)
      if cached?(entry, asset["hash"])
        return %(<script#{type_attr} src="#{esc(url)}"></script>)
      end

      # First visit - inline with cache attributes
      %(<script#{type_attr} sb-asset="#{esc(entry)}:#{esc(asset["hash"])}" sb-url="#{esc(url)}">#{asset["content"]}</script>)
    end

    # Render preload link for critical resources.
    #
    # Use this for fonts, images, or other resources that should load early.
    # Preloaded resources are not cached by Skybolt's Service Worker.
    #
    # @param entry [String] Source file path or direct URL
    # @param as_type [String] Resource type ('image', 'font', 'style', 'script', 'fetch')
    # @param type [String, nil] MIME type (e.g., 'font/woff2', 'image/webp')
    # @param crossorigin [String, nil] Crossorigin attribute ('anonymous', 'use-credentials')
    # @param fetchpriority [String, nil] Fetch priority ('high', 'low', 'auto')
    # @return [String] HTML string
    def preload(entry, as_type:, type: nil, crossorigin: nil, fetchpriority: nil)
      # Try to resolve from assets, fall back to using entry as URL
      url = asset_url(entry) || entry
      url = resolve_url(url)

      attrs = {
        rel: "preload",
        href: url,
        as: as_type
      }
      attrs[:type] = type if type
      attrs[:crossorigin] = crossorigin if crossorigin
      attrs[:fetchpriority] = fetchpriority if fetchpriority

      build_tag("link", attrs)
    end

    # Render the Skybolt client launcher.
    #
    # Call this once in <head> before other Skybolt assets.
    # Outputs config meta tag and client script.
    #
    # On first visit (or cache miss), the launcher is inlined with sb-asset
    # and sb-url attributes so the client can cache itself.
    #
    # On repeat visits (cache hit), returns an external script tag. The Service
    # Worker will serve the launcher from cache (~5ms response time).
    #
    # @return [String] HTML string
    def launch_script
      sw_path = @map.dig("serviceWorker", "path") || "/skybolt-sw.js"
      config = { swPath: sw_path }.to_json

      launcher = @map["launcher"]
      url = resolve_url(launcher["url"])

      meta = %(<meta name="skybolt-config" content="#{esc(config)}">\n)

      if cached?("skybolt-launcher", launcher["hash"])
        # Repeat visit - external script (SW serves from cache)
        return %(#{meta}<script type="module" src="#{esc(url)}"></script>)
      end

      # First visit - inline with sb-asset and sb-url for self-caching
      %(#{meta}<script type="module" sb-asset="skybolt-launcher:#{esc(launcher["hash"])}" sb-url="#{esc(url)}">#{launcher["content"]}</script>)
    end

    # Get URL for an asset (for manual use cases).
    #
    # @param entry [String] Source file path
    # @return [String, nil] Asset URL or nil if not found
    def asset_url(entry)
      url = @map.dig("assets", entry, "url")
      url ? resolve_url(url) : nil
    end

    # Get hash for an asset (for manual use cases).
    #
    # @param entry [String] Source file path
    # @return [String, nil] Asset hash or nil if not found
    def asset_hash(entry)
      @map.dig("assets", entry, "hash")
    end

    # Check if an asset URL is currently cached by the client.
    #
    # This is useful for Chain Lightning integration where we need to check
    # cache status by URL rather than source path.
    #
    # @param url [String] The asset URL (e.g., '/assets/main-Abc123.css')
    # @return [Boolean] True if the asset is cached
    def cached_url?(url)
      # Build URL to entry mapping if not already built
      @url_to_entry ||= begin
        mapping = {}
        (@map["assets"] || {}).each do |entry, asset|
          mapping[asset["url"]] = { "entry" => entry, "hash" => asset["hash"] }
        end
        mapping
      end

      info = @url_to_entry[url]
      return false if info.nil?

      cached?(info["entry"], info["hash"])
    end

    # Check if client has a specific entry:hash pair cached.
    #
    # Useful for external integrations (like Chain Lightning) that manage
    # their own assets outside of Skybolt's render-map.
    #
    # @param entry [String] The entry name (e.g., 'chain-lightning' or 'cl-manifest')
    # @param hash [String] The expected hash value
    # @return [Boolean] True if the entry:hash pair is in the client's cache
    def cached_entry?(entry, hash)
      cached?(entry, hash)
    end

    private

    def resolve_url(url)
      return url if @cdn_url.nil?
      return url if url.start_with?("http://", "https://", "//")

      "#{@cdn_url}#{url}"
    end

    def cached?(entry, hash)
      @client_cache[entry] == hash
    end

    def parse_cookie(cookie)
      return {} if cookie.empty?

      decoded = URI.decode_www_form_component(cookie)
      cache = {}

      decoded.split(",").each do |pair|
        # Find last colon (hash doesn't contain colons, but paths might)
        colon_pos = pair.rindex(":")
        next if colon_pos.nil?

        name = pair[0...colon_pos]
        hash = pair[(colon_pos + 1)..]
        cache[name] = hash
      end

      cache
    end

    def build_tag(tag, attrs)
      attr_str = attrs.map { |k, v| %(#{k}="#{esc(v)}") }.join(" ")
      "<#{tag} #{attr_str}>"
    end

    def esc(value)
      CGI.escapeHTML(value.to_s)
    end

    def comment(text)
      "<!-- #{esc(text)} -->"
    end
  end
end
