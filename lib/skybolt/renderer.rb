# frozen_string_literal: true

require "json"
require "cgi"
require "uri"

module Skybolt
  # Skybolt asset renderer.
  #
  # Reads the render-map.json generated by @skybolt/vite-plugin and outputs
  # optimized HTML tags with intelligent caching via Service Workers.
  class Renderer
    # @param render_map_path [String] Path to render-map.json generated by Vite plugin
    # @param cookies [Hash, nil] Cookie hash (defaults to empty hash)
    # @param cdn_url [String, nil] Optional CDN URL prefix
    def initialize(render_map_path, cookies: nil, cdn_url: nil)
      json = File.read(render_map_path)
      @map = JSON.parse(json)
      @client_cache = parse_cookie((cookies || {})["sb_assets"] || "")
      @cdn_url = cdn_url&.chomp("/")
    end

    # Render CSS asset.
    #
    # On first visit: inlines CSS with sb-* attributes for caching
    # On repeat visit: outputs <link> tag (Service Worker serves from cache)
    #
    # @param entry [String] Source file path (e.g., 'src/css/main.css')
    # @return [String] HTML string
    def css(entry)
      asset = @map.dig("assets", entry)
      return comment("Skybolt: asset not found: #{entry}") if asset.nil?

      url = resolve_url(asset["url"])

      # Client has current version - external link (SW serves from cache)
      if cached?(entry, asset["hash"])
        return %(<link rel="stylesheet" href="#{esc(url)}">)
      end

      # First visit - inline with cache attributes
      %(<style sb-asset="#{esc(entry)}:#{esc(asset["hash"])}" sb-url="#{esc(url)}">#{asset["content"]}</style>)
    end

    # Render JavaScript asset.
    #
    # On first visit: inlines JS with sb-* attributes for caching
    # On repeat visit: outputs <script> tag (Service Worker serves from cache)
    #
    # @param entry [String] Source file path (e.g., 'src/js/app.js')
    # @param is_module [Boolean] Whether to load as ES module (default: true)
    # @return [String] HTML string
    def script(entry, is_module: true)
      asset = @map.dig("assets", entry)
      return comment("Skybolt: asset not found: #{entry}") if asset.nil?

      url = resolve_url(asset["url"])
      type_attr = is_module ? ' type="module"' : ""

      # Client has current version - external script (SW serves from cache)
      if cached?(entry, asset["hash"])
        return %(<script#{type_attr} src="#{esc(url)}"></script>)
      end

      # First visit - inline with cache attributes
      %(<script#{type_attr} sb-asset="#{esc(entry)}:#{esc(asset["hash"])}" sb-url="#{esc(url)}">#{asset["content"]}</script>)
    end

    # Render preload link for critical resources.
    #
    # Use this for fonts, images, or other resources that should load early.
    # Preloaded resources are not cached by Skybolt's Service Worker.
    #
    # @param entry [String] Source file path or direct URL
    # @param as_type [String] Resource type ('image', 'font', 'style', 'script', 'fetch')
    # @param type [String, nil] MIME type (e.g., 'font/woff2', 'image/webp')
    # @param crossorigin [String, nil] Crossorigin attribute ('anonymous', 'use-credentials')
    # @param fetchpriority [String, nil] Fetch priority ('high', 'low', 'auto')
    # @return [String] HTML string
    def preload(entry, as_type:, type: nil, crossorigin: nil, fetchpriority: nil)
      # Try to resolve from assets, fall back to using entry as URL
      url = asset_url(entry) || entry
      url = resolve_url(url)

      attrs = {
        rel: "preload",
        href: url,
        as: as_type
      }
      attrs[:type] = type if type
      attrs[:crossorigin] = crossorigin if crossorigin
      attrs[:fetchpriority] = fetchpriority if fetchpriority

      build_tag("link", attrs)
    end

    # Render the Skybolt client launcher.
    #
    # Call this once in <head> before other Skybolt assets.
    # Outputs config meta tag and client script.
    #
    # @return [String] HTML string
    def launch_script
      sw_path = @map.dig("serviceWorker", "path") || "/skybolt-sw.js"
      config = { swPath: sw_path }.to_json

      %(<meta name="skybolt-config" content="#{esc(config)}">\n<script type="module">#{@map.dig("client", "script")}</script>)
    end

    # Get URL for an asset (for manual use cases).
    #
    # @param entry [String] Source file path
    # @return [String, nil] Asset URL or nil if not found
    def asset_url(entry)
      url = @map.dig("assets", entry, "url")
      url ? resolve_url(url) : nil
    end

    # Get hash for an asset (for manual use cases).
    #
    # @param entry [String] Source file path
    # @return [String, nil] Asset hash or nil if not found
    def asset_hash(entry)
      @map.dig("assets", entry, "hash")
    end

    private

    def resolve_url(url)
      return url if @cdn_url.nil?
      return url if url.start_with?("http://", "https://", "//")

      "#{@cdn_url}#{url}"
    end

    def cached?(entry, hash)
      @client_cache[entry] == hash
    end

    def parse_cookie(cookie)
      return {} if cookie.empty?

      decoded = URI.decode_www_form_component(cookie)
      cache = {}

      decoded.split(",").each do |pair|
        # Find last colon (hash doesn't contain colons, but paths might)
        colon_pos = pair.rindex(":")
        next if colon_pos.nil?

        name = pair[0...colon_pos]
        hash = pair[(colon_pos + 1)..]
        cache[name] = hash
      end

      cache
    end

    def build_tag(tag, attrs)
      attr_str = attrs.map { |k, v| %(#{k}="#{esc(v)}") }.join(" ")
      "<#{tag} #{attr_str}>"
    end

    def esc(value)
      CGI.escapeHTML(value.to_s)
    end

    def comment(text)
      "<!-- #{esc(text)} -->"
    end
  end
end
